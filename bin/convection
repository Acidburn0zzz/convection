#!/usr/bin/env ruby
require 'thor'
require_relative '../lib/convection/control/cloud'

module Convection
  ##
  # Convection CLI
  ##
  class CLI < Thor
    class_option :cloudfile, :type => :string, :default => 'Cloudfile'
    def initialize(*args)
      super
      @cloud = Control::Cloud.new
      @cwd = Dir.getwd
    end

    desc 'converge STACK', 'Converge your cloud'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to converge'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to converge'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress', default: true
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks', default: true
    def converge(stack = nil)
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))
      @cloud.converge(stack, stack_group: options[:stack_group], stacks: options[:stacks], &method(:emit_events))
    end

    desc 'delete STACK', 'Delete stack(s) from your cloud'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to delete'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to delete'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress', default: true
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks', default: true
    def delete(stack = nil)
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))

      stacks = @cloud.stacks_until(stack, options, &method(:emit_events))
      if stacks.empty?
        say_status(:delete_failed, 'No stacks found matching the provided input (STACK, --stack-group, and/or --stacks).', :red)
        return
      end
      say_status(:delete, "Deleting the following stack(s): #{stacks.map(&:name).join(', ')}", :red)

      confirmation = ask('Are you sure you want to delete the above stack(s)?', limited_to: %w(yes no))
      if confirmation.eql?('yes')
        @cloud.delete(stacks, &method(:emit_events))
      else
        say_status(:delete_aborted, 'Aborted deletion of the above stack(s).', :green)
      end
    end

    desc 'diff STACK', 'Show changes that will be applied by converge'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to diff'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to diff'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress'
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks'
    def diff(stack = nil)
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))
      @cloud.diff(stack, stack_group: options[:stack_group], stacks: options[:stacks], &method(:emit_events))
    end

    desc 'print STACK', 'Print the rendered template for STACK'
    def print(stack)
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))
      puts @cloud.stacks[stack].to_json(true)
    end

    desc 'describe-tasks [--stacks STACKS]', 'Describe tasks for a given stack'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to diff', default: []
    def describe_tasks
      @cloud = Control::Cloud.new
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))

      describe_stack_tasks(options[:stacks])
    end

    desc 'run-tasks [--stack STACK]', 'Run tasks for a given stack'
    option :stack, :desc => 'The stack to run tasks for', :required => true
    def run_tasks
      @cloud = Control::Cloud.new
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))

      run_stack_tasks(options[:stack])
    end

    desc 'validate STACK', 'Validate the rendered template for STACK'
    def validate(stack)
      @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))
      @cloud.stacks[stack].validate
    end

    no_commands do
      attr_accessor :last_event

      private

      def describe_stack_tasks(stacks_to_include)
        @cloud.stacks.map do |stack_name, stack|
          next if stacks_to_include.any? && stacks_to_include.include?(stack_name)
          flattened_tasks = stack.tasks.values.flatten
          next if flattened_tasks.empty?

          puts "Stack #{stack_name} (#{stack.cloud_name}) includes the following tasks:"
          flattened_tasks.each_with_index do |task, index|
            puts " #{index}. #{task}"
          end
        end
      end

      def run_stack_tasks(stack_name)
        stack = @cloud.stacks[stack_name]
        if !stack
          say_status(:task_execution_failed, 'No stacks found matching the provided input (--stack).', :red)
          exit 1
        elsif stack.tasks.empty?
          say_status(:task_execution_failed, "No tasks defined for the stack #{stack_name}. Define them in your Cloudfile.", :red)
          exit 1
        end

        puts "The following tasks are available to execute for the stack #{stack_name} (#{stack.cloud_name}):"
        tasks.each_with_index do |task, index|
          puts " #{index}. #{task}"
        end
        choices = 0.upto(tasks.length - 1, &:to_s)
        choice = ask('Which stack task (by number) would you like to execute?', limited_to: choices)
        task = tasks[choice.to_i]

        say_status(:task_in_progress, "Task (#{phase}) #{task} in progress for stack #{stack_name}.", :yellow)
        task.call(stack)

        if task.success?
          say_status(:task_complete, "Task (#{phase}) #{task} successfully completed for stack #{stack_name}.", :green)
        else
          say_status(:task_failed, "Task (#{phase}) #{task} failed to complete for stack #{stack_name}.", :red)
          exit 1
        end
      end

      def emit_events(event, *errors)
        if event.is_a? Model::Event
          if options[:'very-verbose'] || event.name == :error
            say_status(*event.to_thor)
          elsif options[:verbose]
            say_status(*event.to_thor) if event.name == :compare
          end
          @last_event = event
        elsif event.is_a? Model::Diff
          if !options[:'very-verbose'] && !options[:verbose]
            say_status(*last_event.to_thor) unless last_event.nil?
            @last_event = nil
          end
          say_status(*event.to_thor)
        else
          say_status(*event.to_thor)
        end

        errors.each do |error|
          say "* #{ error.message }"
          error.backtrace.each { |trace| say "    #{ trace }" }
        end
      end
    end
  end
end

Convection::CLI.start(ARGV)
