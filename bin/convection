#!/usr/bin/env ruby
require 'thor'
require_relative '../lib/convection/control/cloud'
require 'thread'
module Convection
  ##
  # Convection CLI
  ##
  class CLI < Thor
    def initialize(*args)
      super
      @cwd = Dir.getwd
      @errors = false
    end

    desc 'converge STACK', 'Converge your cloud'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to converge'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to converge'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress', default: true
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks', default: true
    option :cloudfiles, :type => :array, :default => %w(Cloudfile)
    option :delayed_output, :type => :boolean, :desc => 'Delay output until operation completion.', :default => true
    def converge(stack = nil)
      outputs = []
      semaphore = Mutex.new
      work_q = Queue.new
      options[:cloudfiles].each { |cloudfile| work_q.push(cloud: Control::Cloud.new, cloudfile_path: cloudfile) }
      workers = (0...options[:cloudfiles].length).map do
        Thread.new do
          output = []
          until work_q.empty?
            cloud_array = work_q.pop(true)
            cloud_array[:cloud].configure(File.absolute_path(cloud_array[:cloudfile_path], @cwd))
            cloud = cloud_array[:cloud]
            cloud.converge(stack, stack_group: options[:stack_group], stacks: options[:stacks]) do |event, errors|
              if options[:cloudfiles].length > 1 && options[:delayed_output]
                output << { event: event, errors: errors }
              else
                emit_events(event, *errors, region: cloud.cloudfile.region)
              end
              semaphore.synchronize { @errors = errors.any? }
            end
            if options[:cloudfiles].length > 1 && options[:delayed_output]
              semaphore.synchronize { outputs << { region: cloud.cloudfile.region, logging: output } }
            end
          end
        end
      end
      workers.each(&:join)
      print_outputs(outputs) if outputs.any?
      exit 1 if @errors
    end

    desc 'delete STACK', 'Delete stack(s) from your cloud'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to delete'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to delete'
    option :cloudfile, :type => :string, :default => 'Cloudfile'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress', default: true
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks', default: true
    def delete(stack = nil)
      init_cloud

      stacks = @cloud.stacks_until(stack, options, &method(:emit_events))
      if stacks.empty?
        say_status(:delete_failed, 'No stacks found matching the provided input (STACK, --stack-group, and/or --stacks).', :red)
        return
      end
      say_status(:delete, "Deleting the following stack(s): #{stacks.map(&:name).join(', ')}", :red)

      confirmation = ask('Are you sure you want to delete the above stack(s)?', limited_to: %w(yes no))
      if confirmation.eql?('yes')
        @cloud.delete(stacks, &method(:emit_events))
      else
        say_status(:delete_aborted, 'Aborted deletion of the above stack(s).', :green)
      end
    end

    desc 'diff STACK', 'Show changes that will be applied by converge'
    option :stack_group, :type => :string, :desc => 'The name of a stack group defined in your cloudfile to diff'
    option :stacks, :type => :array, :desc => 'A ordered space separated list of stacks to diff'
    option :verbose, :type => :boolean, :aliases => '--v', :desc => 'Show stack progress'
    option :'very-verbose', :type => :boolean, :aliases => '--vv', :desc => 'Show unchanged stacks'
    option :cloudfiles, :type => :array, :default => %w(Cloudfile)
    option :delayed_output, :type => :boolean, :desc => 'Delay output until operation completion.', :default => true
    def diff(stack = nil)
      outputs = []
      semaphore = Mutex.new
      work_q = Queue.new
      options[:cloudfiles].each { |cloudfile| work_q.push(cloud: Control::Cloud.new, cloudfile_path: cloudfile) }
      workers = (0...options[:cloudfiles].length).map do
        Thread.new do
          until work_q.empty?
            output = []
            cloud_array = work_q.pop(true)
            cloud_array[:cloud].configure(File.absolute_path(cloud_array[:cloudfile_path], @cwd))
            cloud = cloud_array[:cloud]
            cloud.diff(stack, stack_group: options[:stack_group], stacks: options[:stacks]) do |event, errors|
              if options[:cloudfiles].length > 1 && options[:delayed_output]
                output << { event: event, errors: errors }
              else
                emit_events(event, *errors, region: cloud.cloudfile.region)
              end
              semaphore.synchronize { @errors = errors.any? }
            end
            if options[:cloudfiles].length > 1 && options[:delayed_output]
              semaphore.synchronize { outputs << { region: cloud.cloudfile.region, logging: output } }
            end
          end
        end
      end
      workers.each(&:join)
      print_outputs(outputs) if outputs.any?
      exit 1 if @errors
    end

    desc 'print_template STACK', 'Print the rendered template for STACK'
    option :cloudfile, :type => :string, :default => 'Cloudfile'
    def print_template(stack)
      init_cloud
      puts @cloud.stacks[stack].to_json(true)
    end

    desc 'validate STACK', 'Validate the rendered template for STACK'
    option :cloudfile, :type => :string, :default => 'Cloudfile'
    def validate(stack)
      init_cloud
      @cloud.stacks[stack].validate
    end

    no_commands do
      attr_accessor :last_event

      private

      def init_cloud
        @cloud = Control::Cloud.new
        @cloud.configure(File.absolute_path(options['cloudfile'], @cwd))
      end

      def emit_events(event, *errors, region: nil)
        if event.is_a? Model::Event
          if options[:'very-verbose'] || event.name == :error
            print_info(event, region: region)
          elsif options[:verbose]
            print_info(event, region: region) if event.name == :compare
          end
          @last_event = event
        elsif event.is_a? Model::Diff
          if !options[:'very-verbose'] && !options[:verbose]
            print_info(last_event, region: region) unless last_event.nil?
            @last_event = nil
          end
          print_info(event, region: region)
        else
          print_info(event, region: region)
        end

        errors.each do |error|
          say "* #{ error.message }"
          error.backtrace.each { |trace| say "    #{ trace }" }
        end
      end

      def print_info(say, region: nil)
        print "#{region} " if region
        say_status(*say.to_thor)
      end

      def print_outputs(outputs)
        outputs.each do |output|
          puts '********'
          puts output[:region]
          puts '********'
          output[:logging].each do |hash|
            emit_events(hash[:event], *hash[:errors])
          end
        end
      end
    end
  end
end

Convection::CLI.start(ARGV)
